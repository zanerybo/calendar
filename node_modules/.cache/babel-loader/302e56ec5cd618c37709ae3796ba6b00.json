{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBody = parseBody;\n\nvar _zlib = _interopRequireDefault(require(\"zlib\"));\n\nvar _querystring = _interopRequireDefault(require(\"querystring\"));\n\nvar _rawBody = _interopRequireDefault(require(\"raw-body\"));\n\nvar _httpErrors = _interopRequireDefault(require(\"http-errors\"));\n\nvar _contentType = _interopRequireDefault(require(\"content-type\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Provided a \"Request\" provided by express or connect (typically a node style\n * HTTPClientRequest), Promise the body data contained.\n */\n\n\nasync function parseBody(req) {\n  const {\n    body\n  } = req; // If express has already parsed a body as a keyed object, use it.\n\n  if (typeof body === 'object' && !(body instanceof Buffer)) {\n    return body;\n  } // Skip requests without content types.\n\n\n  if (req.headers['content-type'] === undefined) {\n    return {};\n  }\n\n  const typeInfo = _contentType.default.parse(req); // If express has already parsed a body as a string, and the content-type\n  // was application/graphql, parse the string body.\n\n\n  if (typeof body === 'string' && typeInfo.type === 'application/graphql') {\n    return {\n      query: body\n    };\n  } // Already parsed body we didn't recognise? Parse nothing.\n\n\n  if (body != null) {\n    return {};\n  }\n\n  const rawBody = await readBody(req, typeInfo); // Use the correct body parser based on Content-Type header.\n\n  switch (typeInfo.type) {\n    case 'application/graphql':\n      return {\n        query: rawBody\n      };\n\n    case 'application/json':\n      if (jsonObjRegex.test(rawBody)) {\n        try {\n          return JSON.parse(rawBody);\n        } catch (error) {// Do nothing\n        }\n      }\n\n      throw (0, _httpErrors.default)(400, 'POST body sent invalid JSON.');\n\n    case 'application/x-www-form-urlencoded':\n      return _querystring.default.parse(rawBody);\n  } // If no Content-Type header matches, parse nothing.\n\n\n  return {};\n}\n/**\n * RegExp to match an Object-opening brace \"{\" as the first non-space\n * in a string. Allowed whitespace is defined in RFC 7159:\n *\n *     ' '   Space\n *     '\\t'  Horizontal tab\n *     '\\n'  Line feed or New line\n *     '\\r'  Carriage return\n */\n\n\nconst jsonObjRegex = /^[ \\t\\n\\r]*\\{/; // Read and parse a request body.\n\nasync function readBody(req, // TODO: Import the appropriate TS type and use it here instead\ntypeInfo) {\n  var _typeInfo$parameters$, _typeInfo$parameters$2; // flowlint-next-line unnecessary-optional-chain:off\n\n\n  const charset = (_typeInfo$parameters$ = (_typeInfo$parameters$2 = typeInfo.parameters.charset) === null || _typeInfo$parameters$2 === void 0 ? void 0 : _typeInfo$parameters$2.toLowerCase()) !== null && _typeInfo$parameters$ !== void 0 ? _typeInfo$parameters$ : 'utf-8'; // Assert charset encoding per JSON RFC 7159 sec 8.1\n\n  if (charset.slice(0, 4) !== 'utf-') {\n    throw (0, _httpErrors.default)(415, `Unsupported charset \"${charset.toUpperCase()}\".`);\n  } // Get content-encoding (e.g. gzip)\n\n\n  const contentEncoding = req.headers['content-encoding'];\n  const encoding = typeof contentEncoding === 'string' ? contentEncoding.toLowerCase() : 'identity';\n  const length = encoding === 'identity' ? req.headers['content-length'] : null;\n  const limit = 100 * 1024; // 100kb\n\n  const stream = decompressed(req, encoding); // Read body from stream.\n\n  try {\n    return await (0, _rawBody.default)(stream, {\n      encoding: charset,\n      length,\n      limit\n    });\n  } catch (err) {\n    throw err.type === 'encoding.unsupported' ? (0, _httpErrors.default)(415, `Unsupported charset \"${charset.toUpperCase()}\".`) : (0, _httpErrors.default)(400, `Invalid body: ${err.message}.`);\n  }\n} // Return a decompressed stream, given an encoding.\n\n\nfunction decompressed(req, encoding) {\n  switch (encoding) {\n    case 'identity':\n      return req;\n\n    case 'deflate':\n      return req.pipe(_zlib.default.createInflate());\n\n    case 'gzip':\n      return req.pipe(_zlib.default.createGunzip());\n  }\n\n  throw (0, _httpErrors.default)(415, `Unsupported content-encoding \"${encoding}\".`);\n}","map":{"version":3,"sources":["C:/Users/a.abramov/calendar/node_modules/express-graphql/parseBody.js"],"names":["Object","defineProperty","exports","value","parseBody","_zlib","_interopRequireDefault","require","_querystring","_rawBody","_httpErrors","_contentType","obj","__esModule","default","req","body","Buffer","headers","undefined","typeInfo","parse","type","query","rawBody","readBody","jsonObjRegex","test","JSON","error","_typeInfo$parameters$","_typeInfo$parameters$2","charset","parameters","toLowerCase","slice","toUpperCase","contentEncoding","encoding","length","limit","stream","decompressed","err","message","pipe","createInflate","createGunzip"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBody = parseBody;\n\nvar _zlib = _interopRequireDefault(require(\"zlib\"));\n\nvar _querystring = _interopRequireDefault(require(\"querystring\"));\n\nvar _rawBody = _interopRequireDefault(require(\"raw-body\"));\n\nvar _httpErrors = _interopRequireDefault(require(\"http-errors\"));\n\nvar _contentType = _interopRequireDefault(require(\"content-type\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Provided a \"Request\" provided by express or connect (typically a node style\n * HTTPClientRequest), Promise the body data contained.\n */\nasync function parseBody(req) {\n  const {\n    body\n  } = req; // If express has already parsed a body as a keyed object, use it.\n\n  if (typeof body === 'object' && !(body instanceof Buffer)) {\n    return body;\n  } // Skip requests without content types.\n\n\n  if (req.headers['content-type'] === undefined) {\n    return {};\n  }\n\n  const typeInfo = _contentType.default.parse(req); // If express has already parsed a body as a string, and the content-type\n  // was application/graphql, parse the string body.\n\n\n  if (typeof body === 'string' && typeInfo.type === 'application/graphql') {\n    return {\n      query: body\n    };\n  } // Already parsed body we didn't recognise? Parse nothing.\n\n\n  if (body != null) {\n    return {};\n  }\n\n  const rawBody = await readBody(req, typeInfo); // Use the correct body parser based on Content-Type header.\n\n  switch (typeInfo.type) {\n    case 'application/graphql':\n      return {\n        query: rawBody\n      };\n\n    case 'application/json':\n      if (jsonObjRegex.test(rawBody)) {\n        try {\n          return JSON.parse(rawBody);\n        } catch (error) {// Do nothing\n        }\n      }\n\n      throw (0, _httpErrors.default)(400, 'POST body sent invalid JSON.');\n\n    case 'application/x-www-form-urlencoded':\n      return _querystring.default.parse(rawBody);\n  } // If no Content-Type header matches, parse nothing.\n\n\n  return {};\n}\n/**\n * RegExp to match an Object-opening brace \"{\" as the first non-space\n * in a string. Allowed whitespace is defined in RFC 7159:\n *\n *     ' '   Space\n *     '\\t'  Horizontal tab\n *     '\\n'  Line feed or New line\n *     '\\r'  Carriage return\n */\n\n\nconst jsonObjRegex = /^[ \\t\\n\\r]*\\{/; // Read and parse a request body.\n\nasync function readBody(req, // TODO: Import the appropriate TS type and use it here instead\ntypeInfo) {\n  var _typeInfo$parameters$, _typeInfo$parameters$2;\n\n  // flowlint-next-line unnecessary-optional-chain:off\n  const charset = (_typeInfo$parameters$ = (_typeInfo$parameters$2 = typeInfo.parameters.charset) === null || _typeInfo$parameters$2 === void 0 ? void 0 : _typeInfo$parameters$2.toLowerCase()) !== null && _typeInfo$parameters$ !== void 0 ? _typeInfo$parameters$ : 'utf-8'; // Assert charset encoding per JSON RFC 7159 sec 8.1\n\n  if (charset.slice(0, 4) !== 'utf-') {\n    throw (0, _httpErrors.default)(415, `Unsupported charset \"${charset.toUpperCase()}\".`);\n  } // Get content-encoding (e.g. gzip)\n\n\n  const contentEncoding = req.headers['content-encoding'];\n  const encoding = typeof contentEncoding === 'string' ? contentEncoding.toLowerCase() : 'identity';\n  const length = encoding === 'identity' ? req.headers['content-length'] : null;\n  const limit = 100 * 1024; // 100kb\n\n  const stream = decompressed(req, encoding); // Read body from stream.\n\n  try {\n    return await (0, _rawBody.default)(stream, {\n      encoding: charset,\n      length,\n      limit\n    });\n  } catch (err) {\n    throw err.type === 'encoding.unsupported' ? (0, _httpErrors.default)(415, `Unsupported charset \"${charset.toUpperCase()}\".`) : (0, _httpErrors.default)(400, `Invalid body: ${err.message}.`);\n  }\n} // Return a decompressed stream, given an encoding.\n\n\nfunction decompressed(req, encoding) {\n  switch (encoding) {\n    case 'identity':\n      return req;\n\n    case 'deflate':\n      return req.pipe(_zlib.default.createInflate());\n\n    case 'gzip':\n      return req.pipe(_zlib.default.createGunzip());\n  }\n\n  throw (0, _httpErrors.default)(415, `Unsupported content-encoding \"${encoding}\".`);\n}\n"]},"metadata":{},"sourceType":"script"}