{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.graphqlHTTP = graphqlHTTP;\nexports.getGraphQLParams = getGraphQLParams;\n\nvar _accepts = _interopRequireDefault(require(\"accepts\"));\n\nvar _httpErrors = _interopRequireDefault(require(\"http-errors\"));\n\nvar _graphql = require(\"graphql\");\n\nvar _parseBody = require(\"./parseBody\");\n\nvar _renderGraphiQL = require(\"./renderGraphiQL\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Middleware for express; takes an options object or function as input to\n * configure behavior, and returns an express middleware.\n */\n\n\nfunction graphqlHTTP(options) {\n  if (!options) {\n    throw new Error('GraphQL middleware requires options.');\n  }\n\n  return async function graphqlMiddleware(request, response) {\n    var _result$errors; // Higher scoped variables are referred to at various stages in the asynchronous state machine below.\n\n\n    let params;\n    let showGraphiQL = false;\n    let graphiqlOptions;\n    let formatErrorFn = _graphql.formatError;\n    let pretty = false;\n    let result;\n\n    try {\n      var _optionsData$validati, _optionsData$graphiql, _optionsData$context, _optionsData$customPa, _optionsData$customEx, _optionsData$customVa, _optionsData$pretty2, _ref2, _optionsData$customFo2; // Parse the Request to get GraphQL request parameters.\n\n\n      try {\n        params = await getGraphQLParams(request);\n      } catch (error) {\n        var _optionsData$pretty, _ref, _optionsData$customFo; // When we failed to parse the GraphQL parameters, we still need to get\n        // the options object, so make an options call to resolve just that.\n\n\n        const optionsData = await resolveOptions();\n        pretty = (_optionsData$pretty = optionsData.pretty) !== null && _optionsData$pretty !== void 0 ? _optionsData$pretty : false;\n        formatErrorFn = (_ref = (_optionsData$customFo = optionsData.customFormatErrorFn) !== null && _optionsData$customFo !== void 0 ? _optionsData$customFo : optionsData.formatError) !== null && _ref !== void 0 ? _ref : formatErrorFn;\n        throw error;\n      } // Then, resolve the Options to get OptionsData.\n\n\n      const optionsData = await resolveOptions(params); // Collect information from the options data object.\n\n      const schema = optionsData.schema;\n      const rootValue = optionsData.rootValue;\n      const validationRules = (_optionsData$validati = optionsData.validationRules) !== null && _optionsData$validati !== void 0 ? _optionsData$validati : [];\n      const fieldResolver = optionsData.fieldResolver;\n      const typeResolver = optionsData.typeResolver;\n      const graphiql = (_optionsData$graphiql = optionsData.graphiql) !== null && _optionsData$graphiql !== void 0 ? _optionsData$graphiql : false;\n      const extensionsFn = optionsData.extensions;\n      const context = (_optionsData$context = optionsData.context) !== null && _optionsData$context !== void 0 ? _optionsData$context : request;\n      const parseFn = (_optionsData$customPa = optionsData.customParseFn) !== null && _optionsData$customPa !== void 0 ? _optionsData$customPa : _graphql.parse;\n      const executeFn = (_optionsData$customEx = optionsData.customExecuteFn) !== null && _optionsData$customEx !== void 0 ? _optionsData$customEx : _graphql.execute;\n      const validateFn = (_optionsData$customVa = optionsData.customValidateFn) !== null && _optionsData$customVa !== void 0 ? _optionsData$customVa : _graphql.validate;\n      pretty = (_optionsData$pretty2 = optionsData.pretty) !== null && _optionsData$pretty2 !== void 0 ? _optionsData$pretty2 : false;\n      formatErrorFn = (_ref2 = (_optionsData$customFo2 = optionsData.customFormatErrorFn) !== null && _optionsData$customFo2 !== void 0 ? _optionsData$customFo2 : optionsData.formatError) !== null && _ref2 !== void 0 ? _ref2 : formatErrorFn; // Assert that schema is required.\n\n      if (schema == null) {\n        throw (0, _httpErrors.default)(500, 'GraphQL middleware options must contain a schema.');\n      } // GraphQL HTTP only supports GET and POST methods.\n\n\n      if (request.method !== 'GET' && request.method !== 'POST') {\n        throw (0, _httpErrors.default)(405, 'GraphQL only supports GET and POST requests.', {\n          headers: {\n            Allow: 'GET, POST'\n          }\n        });\n      } // Get GraphQL params from the request and POST body data.\n\n\n      const {\n        query,\n        variables,\n        operationName\n      } = params;\n      showGraphiQL = canDisplayGraphiQL(request, params) && graphiql !== false;\n\n      if (typeof graphiql !== 'boolean') {\n        graphiqlOptions = graphiql;\n      } // If there is no query, but GraphiQL will be displayed, do not produce\n      // a result, otherwise return a 400: Bad Request.\n\n\n      if (query == null) {\n        if (showGraphiQL) {\n          return respondWithGraphiQL(response, graphiqlOptions);\n        }\n\n        throw (0, _httpErrors.default)(400, 'Must provide query string.');\n      } // Validate Schema\n\n\n      const schemaValidationErrors = (0, _graphql.validateSchema)(schema);\n\n      if (schemaValidationErrors.length > 0) {\n        // Return 500: Internal Server Error if invalid schema.\n        throw (0, _httpErrors.default)(500, 'GraphQL schema validation error.', {\n          graphqlErrors: schemaValidationErrors\n        });\n      } // Parse source to AST, reporting any syntax error.\n\n\n      let documentAST;\n\n      try {\n        documentAST = parseFn(new _graphql.Source(query, 'GraphQL request'));\n      } catch (syntaxError) {\n        // Return 400: Bad Request if any syntax errors errors exist.\n        throw (0, _httpErrors.default)(400, 'GraphQL syntax error.', {\n          graphqlErrors: [syntaxError]\n        });\n      } // Validate AST, reporting any errors.\n\n\n      const validationErrors = validateFn(schema, documentAST, [..._graphql.specifiedRules, ...validationRules]);\n\n      if (validationErrors.length > 0) {\n        // Return 400: Bad Request if any validation errors exist.\n        throw (0, _httpErrors.default)(400, 'GraphQL validation error.', {\n          graphqlErrors: validationErrors\n        });\n      } // Only query operations are allowed on GET requests.\n\n\n      if (request.method === 'GET') {\n        // Determine if this GET request will perform a non-query.\n        const operationAST = (0, _graphql.getOperationAST)(documentAST, operationName);\n\n        if (operationAST && operationAST.operation !== 'query') {\n          // If GraphiQL can be shown, do not perform this query, but\n          // provide it to GraphiQL so that the requester may perform it\n          // themselves if desired.\n          if (showGraphiQL) {\n            return respondWithGraphiQL(response, graphiqlOptions, params);\n          } // Otherwise, report a 405: Method Not Allowed error.\n\n\n          throw (0, _httpErrors.default)(405, `Can only perform a ${operationAST.operation} operation from a POST request.`, {\n            headers: {\n              Allow: 'POST'\n            }\n          });\n        }\n      } // Perform the execution, reporting any errors creating the context.\n\n\n      try {\n        result = await executeFn({\n          schema,\n          document: documentAST,\n          rootValue,\n          contextValue: context,\n          variableValues: variables,\n          operationName,\n          fieldResolver,\n          typeResolver\n        });\n      } catch (contextError) {\n        // Return 400: Bad Request if any execution context errors exist.\n        throw (0, _httpErrors.default)(400, 'GraphQL execution context error.', {\n          graphqlErrors: [contextError]\n        });\n      } // Collect and apply any metadata extensions if a function was provided.\n      // https://graphql.github.io/graphql-spec/#sec-Response-Format\n\n\n      if (extensionsFn) {\n        const extensions = await extensionsFn({\n          document: documentAST,\n          variables,\n          operationName,\n          result,\n          context\n        });\n\n        if (extensions != null) {\n          result = { ...result,\n            extensions\n          };\n        }\n      }\n    } catch (error) {\n      var _error$status, _error$graphqlErrors; // If an error was caught, report the httpError status, or 500.\n\n\n      response.statusCode = (_error$status = error.status) !== null && _error$status !== void 0 ? _error$status : 500;\n\n      if (error.headers != null) {\n        for (const [key, value] of Object.entries(error.headers)) {\n          response.setHeader(key, value);\n        }\n      }\n\n      result = {\n        data: undefined,\n        errors: (_error$graphqlErrors = error.graphqlErrors) !== null && _error$graphqlErrors !== void 0 ? _error$graphqlErrors : [error]\n      };\n    } // If no data was included in the result, that indicates a runtime query\n    // error, indicate as such with a generic status code.\n    // Note: Information about the error itself will still be contained in\n    // the resulting JSON payload.\n    // https://graphql.github.io/graphql-spec/#sec-Data\n\n\n    if (response.statusCode === 200 && result.data == null) {\n      response.statusCode = 500;\n    } // Format any encountered errors.\n\n\n    const formattedResult = { ...result,\n      errors: (_result$errors = result.errors) === null || _result$errors === void 0 ? void 0 : _result$errors.map(formatErrorFn)\n    }; // If allowed to show GraphiQL, present it instead of JSON.\n\n    if (showGraphiQL) {\n      return respondWithGraphiQL(response, graphiqlOptions, params, formattedResult);\n    } // If \"pretty\" JSON isn't requested, and the server provides a\n    // response.json method (express), use that directly.\n    // Otherwise use the simplified sendResponse method.\n\n\n    if (!pretty && typeof response.json === 'function') {\n      response.json(formattedResult);\n    } else {\n      const payload = JSON.stringify(formattedResult, null, pretty ? 2 : 0);\n      sendResponse(response, 'application/json', payload);\n    }\n\n    async function resolveOptions(requestParams) {\n      const optionsResult = await Promise.resolve(typeof options === 'function' ? options(request, response, requestParams) : options); // Assert that optionsData is in fact an Object.\n\n      if (optionsResult == null || typeof optionsResult !== 'object') {\n        throw new Error('GraphQL middleware option function must return an options object or a promise which will be resolved to an options object.');\n      }\n\n      if (optionsResult.formatError) {\n        // eslint-disable-next-line no-console\n        console.warn('`formatError` is deprecated and replaced by `customFormatErrorFn`. It will be removed in version 1.0.0.');\n      }\n\n      return optionsResult;\n    }\n  };\n}\n\nfunction respondWithGraphiQL(response, options, params, result) {\n  const data = {\n    query: params === null || params === void 0 ? void 0 : params.query,\n    variables: params === null || params === void 0 ? void 0 : params.variables,\n    operationName: params === null || params === void 0 ? void 0 : params.operationName,\n    result\n  };\n  const payload = (0, _renderGraphiQL.renderGraphiQL)(data, options);\n  return sendResponse(response, 'text/html', payload);\n}\n/**\n * Provided a \"Request\" provided by express or connect (typically a node style\n * HTTPClientRequest), Promise the GraphQL request parameters.\n */\n\n\nasync function getGraphQLParams(request) {\n  var _urlData$get, _urlData$get2;\n\n  const urlData = new URLSearchParams(request.url.split('?')[1]);\n  const bodyData = await (0, _parseBody.parseBody)(request); // GraphQL Query string.\n\n  let query = (_urlData$get = urlData.get('query')) !== null && _urlData$get !== void 0 ? _urlData$get : bodyData.query;\n\n  if (typeof query !== 'string') {\n    query = null;\n  } // Parse the variables if needed.\n\n\n  let variables = (_urlData$get2 = urlData.get('variables')) !== null && _urlData$get2 !== void 0 ? _urlData$get2 : bodyData.variables;\n\n  if (typeof variables === 'string') {\n    try {\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw (0, _httpErrors.default)(400, 'Variables are invalid JSON.');\n    }\n  } else if (typeof variables !== 'object') {\n    variables = null;\n  } // Name of GraphQL operation to execute.\n\n\n  let operationName = urlData.get('operationName') || bodyData.operationName;\n\n  if (typeof operationName !== 'string') {\n    operationName = null;\n  }\n\n  const raw = urlData.get('raw') != null || bodyData.raw !== undefined;\n  return {\n    query,\n    variables,\n    operationName,\n    raw\n  };\n}\n/**\n * Helper function to determine if GraphiQL can be displayed.\n */\n\n\nfunction canDisplayGraphiQL(request, params) {\n  // If `raw` false, GraphiQL mode is not enabled.\n  // Allowed to show GraphiQL if not requested as raw and this request prefers HTML over JSON.\n  return !params.raw && (0, _accepts.default)(request).types(['json', 'html']) === 'html';\n}\n/**\n * Helper function for sending a response using only the core Node server APIs.\n */\n\n\nfunction sendResponse(response, type, data) {\n  const chunk = Buffer.from(data, 'utf8');\n  response.setHeader('Content-Type', type + '; charset=utf-8');\n  response.setHeader('Content-Length', String(chunk.length));\n  response.end(chunk);\n}","map":{"version":3,"sources":["C:/Users/a.abramov/calendar/node_modules/express-graphql/index.js"],"names":["Object","defineProperty","exports","value","graphqlHTTP","getGraphQLParams","_accepts","_interopRequireDefault","require","_httpErrors","_graphql","_parseBody","_renderGraphiQL","obj","__esModule","default","options","Error","graphqlMiddleware","request","response","_result$errors","params","showGraphiQL","graphiqlOptions","formatErrorFn","formatError","pretty","result","_optionsData$validati","_optionsData$graphiql","_optionsData$context","_optionsData$customPa","_optionsData$customEx","_optionsData$customVa","_optionsData$pretty2","_ref2","_optionsData$customFo2","error","_optionsData$pretty","_ref","_optionsData$customFo","optionsData","resolveOptions","customFormatErrorFn","schema","rootValue","validationRules","fieldResolver","typeResolver","graphiql","extensionsFn","extensions","context","parseFn","customParseFn","parse","executeFn","customExecuteFn","execute","validateFn","customValidateFn","validate","method","headers","Allow","query","variables","operationName","canDisplayGraphiQL","respondWithGraphiQL","schemaValidationErrors","validateSchema","length","graphqlErrors","documentAST","Source","syntaxError","validationErrors","specifiedRules","operationAST","getOperationAST","operation","document","contextValue","variableValues","contextError","_error$status","_error$graphqlErrors","statusCode","status","key","entries","setHeader","data","undefined","errors","formattedResult","map","json","payload","JSON","stringify","sendResponse","requestParams","optionsResult","Promise","resolve","console","warn","renderGraphiQL","_urlData$get","_urlData$get2","urlData","URLSearchParams","url","split","bodyData","parseBody","get","raw","types","type","chunk","Buffer","from","String","end"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.graphqlHTTP = graphqlHTTP;\nexports.getGraphQLParams = getGraphQLParams;\n\nvar _accepts = _interopRequireDefault(require(\"accepts\"));\n\nvar _httpErrors = _interopRequireDefault(require(\"http-errors\"));\n\nvar _graphql = require(\"graphql\");\n\nvar _parseBody = require(\"./parseBody\");\n\nvar _renderGraphiQL = require(\"./renderGraphiQL\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Middleware for express; takes an options object or function as input to\n * configure behavior, and returns an express middleware.\n */\nfunction graphqlHTTP(options) {\n  if (!options) {\n    throw new Error('GraphQL middleware requires options.');\n  }\n\n  return async function graphqlMiddleware(request, response) {\n    var _result$errors;\n\n    // Higher scoped variables are referred to at various stages in the asynchronous state machine below.\n    let params;\n    let showGraphiQL = false;\n    let graphiqlOptions;\n    let formatErrorFn = _graphql.formatError;\n    let pretty = false;\n    let result;\n\n    try {\n      var _optionsData$validati, _optionsData$graphiql, _optionsData$context, _optionsData$customPa, _optionsData$customEx, _optionsData$customVa, _optionsData$pretty2, _ref2, _optionsData$customFo2;\n\n      // Parse the Request to get GraphQL request parameters.\n      try {\n        params = await getGraphQLParams(request);\n      } catch (error) {\n        var _optionsData$pretty, _ref, _optionsData$customFo;\n\n        // When we failed to parse the GraphQL parameters, we still need to get\n        // the options object, so make an options call to resolve just that.\n        const optionsData = await resolveOptions();\n        pretty = (_optionsData$pretty = optionsData.pretty) !== null && _optionsData$pretty !== void 0 ? _optionsData$pretty : false;\n        formatErrorFn = (_ref = (_optionsData$customFo = optionsData.customFormatErrorFn) !== null && _optionsData$customFo !== void 0 ? _optionsData$customFo : optionsData.formatError) !== null && _ref !== void 0 ? _ref : formatErrorFn;\n        throw error;\n      } // Then, resolve the Options to get OptionsData.\n\n\n      const optionsData = await resolveOptions(params); // Collect information from the options data object.\n\n      const schema = optionsData.schema;\n      const rootValue = optionsData.rootValue;\n      const validationRules = (_optionsData$validati = optionsData.validationRules) !== null && _optionsData$validati !== void 0 ? _optionsData$validati : [];\n      const fieldResolver = optionsData.fieldResolver;\n      const typeResolver = optionsData.typeResolver;\n      const graphiql = (_optionsData$graphiql = optionsData.graphiql) !== null && _optionsData$graphiql !== void 0 ? _optionsData$graphiql : false;\n      const extensionsFn = optionsData.extensions;\n      const context = (_optionsData$context = optionsData.context) !== null && _optionsData$context !== void 0 ? _optionsData$context : request;\n      const parseFn = (_optionsData$customPa = optionsData.customParseFn) !== null && _optionsData$customPa !== void 0 ? _optionsData$customPa : _graphql.parse;\n      const executeFn = (_optionsData$customEx = optionsData.customExecuteFn) !== null && _optionsData$customEx !== void 0 ? _optionsData$customEx : _graphql.execute;\n      const validateFn = (_optionsData$customVa = optionsData.customValidateFn) !== null && _optionsData$customVa !== void 0 ? _optionsData$customVa : _graphql.validate;\n      pretty = (_optionsData$pretty2 = optionsData.pretty) !== null && _optionsData$pretty2 !== void 0 ? _optionsData$pretty2 : false;\n      formatErrorFn = (_ref2 = (_optionsData$customFo2 = optionsData.customFormatErrorFn) !== null && _optionsData$customFo2 !== void 0 ? _optionsData$customFo2 : optionsData.formatError) !== null && _ref2 !== void 0 ? _ref2 : formatErrorFn; // Assert that schema is required.\n\n      if (schema == null) {\n        throw (0, _httpErrors.default)(500, 'GraphQL middleware options must contain a schema.');\n      } // GraphQL HTTP only supports GET and POST methods.\n\n\n      if (request.method !== 'GET' && request.method !== 'POST') {\n        throw (0, _httpErrors.default)(405, 'GraphQL only supports GET and POST requests.', {\n          headers: {\n            Allow: 'GET, POST'\n          }\n        });\n      } // Get GraphQL params from the request and POST body data.\n\n\n      const {\n        query,\n        variables,\n        operationName\n      } = params;\n      showGraphiQL = canDisplayGraphiQL(request, params) && graphiql !== false;\n\n      if (typeof graphiql !== 'boolean') {\n        graphiqlOptions = graphiql;\n      } // If there is no query, but GraphiQL will be displayed, do not produce\n      // a result, otherwise return a 400: Bad Request.\n\n\n      if (query == null) {\n        if (showGraphiQL) {\n          return respondWithGraphiQL(response, graphiqlOptions);\n        }\n\n        throw (0, _httpErrors.default)(400, 'Must provide query string.');\n      } // Validate Schema\n\n\n      const schemaValidationErrors = (0, _graphql.validateSchema)(schema);\n\n      if (schemaValidationErrors.length > 0) {\n        // Return 500: Internal Server Error if invalid schema.\n        throw (0, _httpErrors.default)(500, 'GraphQL schema validation error.', {\n          graphqlErrors: schemaValidationErrors\n        });\n      } // Parse source to AST, reporting any syntax error.\n\n\n      let documentAST;\n\n      try {\n        documentAST = parseFn(new _graphql.Source(query, 'GraphQL request'));\n      } catch (syntaxError) {\n        // Return 400: Bad Request if any syntax errors errors exist.\n        throw (0, _httpErrors.default)(400, 'GraphQL syntax error.', {\n          graphqlErrors: [syntaxError]\n        });\n      } // Validate AST, reporting any errors.\n\n\n      const validationErrors = validateFn(schema, documentAST, [..._graphql.specifiedRules, ...validationRules]);\n\n      if (validationErrors.length > 0) {\n        // Return 400: Bad Request if any validation errors exist.\n        throw (0, _httpErrors.default)(400, 'GraphQL validation error.', {\n          graphqlErrors: validationErrors\n        });\n      } // Only query operations are allowed on GET requests.\n\n\n      if (request.method === 'GET') {\n        // Determine if this GET request will perform a non-query.\n        const operationAST = (0, _graphql.getOperationAST)(documentAST, operationName);\n\n        if (operationAST && operationAST.operation !== 'query') {\n          // If GraphiQL can be shown, do not perform this query, but\n          // provide it to GraphiQL so that the requester may perform it\n          // themselves if desired.\n          if (showGraphiQL) {\n            return respondWithGraphiQL(response, graphiqlOptions, params);\n          } // Otherwise, report a 405: Method Not Allowed error.\n\n\n          throw (0, _httpErrors.default)(405, `Can only perform a ${operationAST.operation} operation from a POST request.`, {\n            headers: {\n              Allow: 'POST'\n            }\n          });\n        }\n      } // Perform the execution, reporting any errors creating the context.\n\n\n      try {\n        result = await executeFn({\n          schema,\n          document: documentAST,\n          rootValue,\n          contextValue: context,\n          variableValues: variables,\n          operationName,\n          fieldResolver,\n          typeResolver\n        });\n      } catch (contextError) {\n        // Return 400: Bad Request if any execution context errors exist.\n        throw (0, _httpErrors.default)(400, 'GraphQL execution context error.', {\n          graphqlErrors: [contextError]\n        });\n      } // Collect and apply any metadata extensions if a function was provided.\n      // https://graphql.github.io/graphql-spec/#sec-Response-Format\n\n\n      if (extensionsFn) {\n        const extensions = await extensionsFn({\n          document: documentAST,\n          variables,\n          operationName,\n          result,\n          context\n        });\n\n        if (extensions != null) {\n          result = { ...result,\n            extensions\n          };\n        }\n      }\n    } catch (error) {\n      var _error$status, _error$graphqlErrors;\n\n      // If an error was caught, report the httpError status, or 500.\n      response.statusCode = (_error$status = error.status) !== null && _error$status !== void 0 ? _error$status : 500;\n\n      if (error.headers != null) {\n        for (const [key, value] of Object.entries(error.headers)) {\n          response.setHeader(key, value);\n        }\n      }\n\n      result = {\n        data: undefined,\n        errors: (_error$graphqlErrors = error.graphqlErrors) !== null && _error$graphqlErrors !== void 0 ? _error$graphqlErrors : [error]\n      };\n    } // If no data was included in the result, that indicates a runtime query\n    // error, indicate as such with a generic status code.\n    // Note: Information about the error itself will still be contained in\n    // the resulting JSON payload.\n    // https://graphql.github.io/graphql-spec/#sec-Data\n\n\n    if (response.statusCode === 200 && result.data == null) {\n      response.statusCode = 500;\n    } // Format any encountered errors.\n\n\n    const formattedResult = { ...result,\n      errors: (_result$errors = result.errors) === null || _result$errors === void 0 ? void 0 : _result$errors.map(formatErrorFn)\n    }; // If allowed to show GraphiQL, present it instead of JSON.\n\n    if (showGraphiQL) {\n      return respondWithGraphiQL(response, graphiqlOptions, params, formattedResult);\n    } // If \"pretty\" JSON isn't requested, and the server provides a\n    // response.json method (express), use that directly.\n    // Otherwise use the simplified sendResponse method.\n\n\n    if (!pretty && typeof response.json === 'function') {\n      response.json(formattedResult);\n    } else {\n      const payload = JSON.stringify(formattedResult, null, pretty ? 2 : 0);\n      sendResponse(response, 'application/json', payload);\n    }\n\n    async function resolveOptions(requestParams) {\n      const optionsResult = await Promise.resolve(typeof options === 'function' ? options(request, response, requestParams) : options); // Assert that optionsData is in fact an Object.\n\n      if (optionsResult == null || typeof optionsResult !== 'object') {\n        throw new Error('GraphQL middleware option function must return an options object or a promise which will be resolved to an options object.');\n      }\n\n      if (optionsResult.formatError) {\n        // eslint-disable-next-line no-console\n        console.warn('`formatError` is deprecated and replaced by `customFormatErrorFn`. It will be removed in version 1.0.0.');\n      }\n\n      return optionsResult;\n    }\n  };\n}\n\nfunction respondWithGraphiQL(response, options, params, result) {\n  const data = {\n    query: params === null || params === void 0 ? void 0 : params.query,\n    variables: params === null || params === void 0 ? void 0 : params.variables,\n    operationName: params === null || params === void 0 ? void 0 : params.operationName,\n    result\n  };\n  const payload = (0, _renderGraphiQL.renderGraphiQL)(data, options);\n  return sendResponse(response, 'text/html', payload);\n}\n\n/**\n * Provided a \"Request\" provided by express or connect (typically a node style\n * HTTPClientRequest), Promise the GraphQL request parameters.\n */\nasync function getGraphQLParams(request) {\n  var _urlData$get, _urlData$get2;\n\n  const urlData = new URLSearchParams(request.url.split('?')[1]);\n  const bodyData = await (0, _parseBody.parseBody)(request); // GraphQL Query string.\n\n  let query = (_urlData$get = urlData.get('query')) !== null && _urlData$get !== void 0 ? _urlData$get : bodyData.query;\n\n  if (typeof query !== 'string') {\n    query = null;\n  } // Parse the variables if needed.\n\n\n  let variables = (_urlData$get2 = urlData.get('variables')) !== null && _urlData$get2 !== void 0 ? _urlData$get2 : bodyData.variables;\n\n  if (typeof variables === 'string') {\n    try {\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw (0, _httpErrors.default)(400, 'Variables are invalid JSON.');\n    }\n  } else if (typeof variables !== 'object') {\n    variables = null;\n  } // Name of GraphQL operation to execute.\n\n\n  let operationName = urlData.get('operationName') || bodyData.operationName;\n\n  if (typeof operationName !== 'string') {\n    operationName = null;\n  }\n\n  const raw = urlData.get('raw') != null || bodyData.raw !== undefined;\n  return {\n    query,\n    variables,\n    operationName,\n    raw\n  };\n}\n/**\n * Helper function to determine if GraphiQL can be displayed.\n */\n\n\nfunction canDisplayGraphiQL(request, params) {\n  // If `raw` false, GraphiQL mode is not enabled.\n  // Allowed to show GraphiQL if not requested as raw and this request prefers HTML over JSON.\n  return !params.raw && (0, _accepts.default)(request).types(['json', 'html']) === 'html';\n}\n/**\n * Helper function for sending a response using only the core Node server APIs.\n */\n\n\nfunction sendResponse(response, type, data) {\n  const chunk = Buffer.from(data, 'utf8');\n  response.setHeader('Content-Type', type + '; charset=utf-8');\n  response.setHeader('Content-Length', String(chunk.length));\n  response.end(chunk);\n}\n"]},"metadata":{},"sourceType":"script"}